<h1 align="center"><b>COS2101</b></h1>
<h3 align="center">Procedural Programming การเขียนโปรแกรมเชิงกระบวนคำสั่ง</h3>

<br>
<h2 style="text-indent: 2em; text-decoration: underline;">เนื้อหาที่ได้รับ</h2>
1. เข้าใจหลักการทำงานของ struct ซึ่งเป็นจุดเริ่มต้นของโครงสร้าง class ในวิชา OOP ขั้นถัดไป<br>
2. แยกความต่างระหว่างการใช้งานพารามิเตอร์แบบ Pass by value และ Pass by reference<br>
3. เข้าใจโครงสร้างแบบ Linked list เบื้องต้น ไว้ใช้ในการเรียนวิชาโครงสร้าง 2103 ในขั้นถัดไป<br>
4. ทราบวิธีการใช้งานคำสั่งอ่านไฟล์ รวมถึงการบันทึกไฟล์เพื่อจัดเก็บลงเครื่อง<br>
<br>
<h2 style="text-indent: 2em; text-decoration: underline;">ผลการเรียนรู้</h2>
<br>
<h2 style="text-indent: 2em; text-decoration: underline;">อธิบายการทำงาน</h2>
1. เริ่มต้นเราจะมีตัวแปร c ในการจัดเก็บค่าช้อยส์ เพื่อเรียกใช้คำสั่งในเมนูต่างๆ, struct sode จริงๆควรมีตัวแปรที่เก็บชื่อและจำนวนเงินฝากด้วย แต่เนื่องจากกอล์ฟทำในคอมที่ม.จึงต้องกลับมาเขียนโค้ดใหม่ สตรัคนี้จริงๆก็ควรชื่อ struct node 
แต่กอล์ฟต้องการที่จะเข้าใจการใช้แกรมม่าจริงๆ ไม่อยากจำแพทเทิร์น จึงเปลี่ยนชื่อนิดหน่อยค่ะ และตัวแปร n ในการกำหนดค่า x ที่อยู่ภายใน struct<br>

![Struct](https://raw.githubusercontent.com/SmileCat42/Basic-of-app-bank-2101-Procedural-Programing-/main/pic/GHstruct.jpeg)

<br>2. เมื่อรันโปรแกรม ระบบจะพามาที่หน้าเมนู และเรียกใช้ฟังก์ชั่น getchoice ต้องการรับค่า c จากแป้นพิมพ์ อันดับแรกเราควรที่จะใส่เลข 1 (add data) เพื่อสร้างตัวแปรตัวแรก รวมถึงการเป็น head ของ node ด้วย เราจะได้ค่าแรกคือ 1 และ n+1 ด้วยเช่นกัน<br>
![Getchoice](https://raw.githubusercontent.com/SmileCat42/Basic-of-app-bank-2101-Procedural-Programing-/main/pic/GHgetchoice.jpeg)

<br>3. เวลาเรียกใช้งานฟังก์ชั่น adddata() โปรแกรมจะทำการจองพื้นที่ขึ้นมา 1 ทุกครั้ง พร้อมใส่ค่า n เข้าไปที่ w ให้ q=พารามิเตอร์ตัวแรกที่ส่งเข้ามาก็คือ head หลังจากนั้นจะตรวจสอบว่า q หรือ head นั้นชี้ไปที่ null หรือไม่ ซึ่งปกติแล้วถ้าเรายังไม่เคย adddata เลย ระบบจะทำงานที่คำสั่งนี้ แต่ถ้าหลังจากที่เราสร้างตัวแปรขึ้นมาแล้ว 1 ตัว การ adddata จะไม่ทำคำสั่งนี้อีกแล้ว เพราะ head จะชี้ไปที่ตัวแรกแทน หลังจากนั้นจะเป็นคำสั่งตรวจสอบว่าตัวสุดท้ายอยู่ที่ใด ปกติแล้วตัวแปรตัวแลกหรือที่อยู่กึ่งกลางจะมีตัว node หรือ link ชี้ไปตัวถัดไปเสมอ ยกเว้นตัวสุดท้ายที่ชี้ไปที่ null หากเราเจอตัวที่ชี้ไปที่ null แสดงว่าเราเจอตัวสุดท้าย และทำคำสั่งให้ link ของตัวสุดท้าย ชี้มาที่ตัวที่เราจองพื้นที่ไว้ก็คือ p นั่นเอง<br>
![Add](https://raw.githubusercontent.com/SmileCat42/Basic-of-app-bank-2101-Procedural-Programing-/main/pic/GHadd.jpeg)

<br>4. สมมติว่าเราสร้างตัวแปร 4 ตัว (output) กด 5 เพื่อโชว์ข้อมูลของตัวแปรทั้งหมด จะเห็นว่าคำสั่งเราที่เราดักคือ head ชี้ไปที่ null ไหม ถ้าใช่นั่นหมายความว่าเรายังไม่มีได้สร้างตัวแปรเลยสักตัว(ยังไม่ได้กด 1 เลย) ระบบจะรีเทิรน์ 0 และจบฟังก์ชั่นทันที แต่ถ้ามีจะเข้าลูปแสดงผล จนถึง head=head->link; เพื่อให้โหนดชี้ไปตัวถัดไป อารมณ์เหมือน +1 นั่นเอง และก็ทำลูปซ้ำๆจนแสดงผลครบตามจำนวน<br>
![Show](https://raw.githubusercontent.com/SmileCat42/Basic-of-app-bank-2101-Procedural-Programing-/main/pic/GHshow.jpeg)

<br>5. เราสามารถ insert ได้ คือการแทรกตัวแปรเข้าไปกึ่งกลางหรือหัวหรือท้ายได้หมดเลย ปกติเราจะแทรกโดยการต่อท้ายในตำแหน่งที่... ซึ่งระบบจะหาตำแหน่งที่เราต้องการต่อท้ายก่อน(ได้จากแป้นพิมพ์) หลังจากนั้นจะให้ตัวใหม่ชี้ไปตำแหน่งเดียวกันกับตัวที่เราพิมพ์ไป แล้วจึงเปลี่ยนให้ตัวก่อนหน้ามาชี้ตัวใหม่แทน แต่ถ้าหากเรากด before นั่นหมายความว่า มีโอกาสที่ผู้ใช้จะแทรกเข้าไปเป็นตัวแรกของโหนดได้ ซึ่่งอัลกอใส่ตัวแรกจะไม่เหมือนกับแทรกแบบทั่วไป เราจะต้องกำหนด head เท่ากับตัวใหม่ด้วย แล้วให้ head ตัวใหม่ชี้มาที่ head เก่าแทน แต่ถ้าแทรกแบบทั่วไปสำหรับ before เราต้องจัดเก็บ temp ของตัวก่อนหน้าด้วย(prv) เพื่อที่จะให้ตัวใหม่(prv)ชี้ไปตำแหน่งเดียวกันกับที่ตัวก่อนหน้าชี้ แล้วจึงค่อยปรับให้ตัวก่อนหน้าชี้มาที่ตัวใหม่ จะทำให้ชุดข้อมูลเรียงกันได้อย่างถูกต้อง<br>
![Insert](https://raw.githubusercontent.com/SmileCat42/Basic-of-app-bank-2101-Procedural-Programing-/main/pic/GHinsert.jpeg)

<br>
<br>6. การ delete จะใช้หลักการเดียวกันกับ insert คือ หาตำแหน่งที่ต้องการก่อน ซึ่งการ delete จำเป็นต้องมีตัวแปรในการเก็บข้อมูลตัวก่อนหน้าของตำแหน่งที่ต้องการจะลบหรือ prv นั่นเอง ในลูปเราจะสร้างตัววิ่งก็คือ q ในการท่องโหนดหรือไล่หาดูว่าตำแหน่งที่ต้องการจะลบอยู่ที่ใด เราจะใช้ค่าที่อยู่ในโหนดก็คือ w ในการกำกับการหาตำแหน่ง คำสั่งแรก if(x==q->w) จะหาว่าใช่ตำแหน่งแรกหรือเปล่า ถ้าใช่ก็จะต้องลบ head ปัจจุบัน พร้อมทั้งตั้ง head เป็นตัวถัดไปแทน ถ้าไม่ใช่ก็จะรันคำสั่งถัดไปคือ while(q->w!=x) เพื่อหาตำแหน่งที่จะลบ เมื่อเจอแล้วจะเด้งออกจากลูปทันที แล้วเข้าไปที่ if(q->w==x) เพื่อตั้งค่าให้ prv ชี้ไปตำแหน่งเดียวกันกับตัวที่ต้องการจะลบ แล้วทำการลบตัวดังกล่าว<br>

![Delete](https://raw.githubusercontent.com/SmileCat42/Basic-of-app-bank-2101-Procedural-Programing-/main/pic/GHdelete.jpeg)

<br>
<br>7. การ sort จะใช้ลูป 2 ชั้น โดยที่ลูปแรกจะเอาไปเทียบกับสมาชิกที่เหลือ ซึ่งจำเป็นต้องไล่ทีละตัวโดยการใช้อีกลูปนึง หากเทียบกันแล้วค่าจากลูปที่ 2 มีค่ามากกว่าลูปแรก จะดึงเข้าฟังก์ชั่น swap ก็คือสลับ โดยการส่งอากิวเม้น 2 ตัว (ตัวตั้ง,ตัวเทียบ) พอสลับเสร็จ ลูปที่ 2 ก็จะเอาตัวถัดไปมาเทียบต่อ หากเทียบครบแล้วเราจะได้ค่าที่สูงที่สุดอยู่ที่ head แล้ว(เป็นการสลับค่า ไม่ใช่สลับโหนด) คราวนี้ลูปแรกถึงจะเปลี่ยนตัวตั้งเป็นตัวถัดไป ลูปที่ 2 ก็จะเริ่มใหม่เอาทุกตัวยกเว้นตัวที่ลูปแรกทำไปแล้ว ไปเทียบอีกครั้งจนครบทุกคู่ จึงจะออกจากคำสั่งได้โหนดที่เรียงค่าจากมากไปน้อย<br>

![Sort](https://raw.githubusercontent.com/SmileCat42/Basic-of-app-bank-2101-Procedural-Programing-/main/pic/GHsort.jpeg)
<br>
<br>8. การบันทึกไฟล์หรือโหลดไฟล์มีหลักการคล้ายๆกันคือ เราต้องมีภาพในหัวว่ารูปแบบหรือแพทเทิรน์ที่เราจะบันทึกตัวอักษรจะเป็นลักษณะใด ซึ่งวิชานี้สอนแบบเบสิก ยังไม่ซับซ้อนมาก จึงควรบันทึกในลักษณะเดียวกันทั้งหมด อย่างในโปรแกรมนี้กอล์ฟจะใช้กำกับด้วย "Node : " ทั้งหมดและใส่ค่าต่อท้ายขึ้นบรรทัดใหม่ คำสั่ง FILE *fp; เป็นการสร้างตัวแปรในการเปิดไฟล์และ fp=fopen(ff,"wt"); เป็นการกำหนดรูปแบบการกระทำกับไฟล์ กรณีนี้ใช้ wt คือการเขียน write text โดยการบันทึกไปที่ ff ซึ่งเก็บ string ที่อยู่ในการจัดเก็บไฟล์เช่น (C:/VS code) ระบบก็จะทำการไล่ทีละตัวอักษรถ้าเป็นการบันทึกเราจะใช้ fprintf ถ้าโหลดไฟล์จะใช้ fscanf คล้ายๆกับการแสดงผลผ่านหน้าจอแบบ printf และสิ่งที่ห้ามลืมคือ การลบตัวแปรอ่านไฟล์ด้วยทุกครั้ง fclose(fp);<br>
![File](https://raw.githubusercontent.com/SmileCat42/Basic-of-app-bank-2101-Procedural-Programing-/main/pic/GHfile.jpeg)
